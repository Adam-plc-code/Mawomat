TYPE "ParamSequencerControl"
VERSION : 0.1
   STRUCT
      Start : Bool;   // Start sekwencji
      Pause : Bool;   // Pauza sekwencji - krok sie nie zmienia, sterowanie wylaczone
      ManualMode : Bool;   // Sterowanie reczne sekwencerem
      SimulationMode : Bool;   // Symulacja sekwencera bez wykonywania działań
      StepNb : Int;   // Aktualny krok
      NextStepNb : Int;
      ManualStepNb : Int;   // Manualny przeskok do kroku
      ManualStepUp : Bool;   // Manualny przeskok do następnego kroku
      ManualStepDown : Bool;   // Manualny przeskok do poprzedniego kroku
      StartTimeET : Time;
      EndTimeET : Time;
      MaxTimeET : Time;
   END_STRUCT;

END_TYPE

TYPE "ParamSequencerStep"
VERSION : 0.1
   STRUCT
      StepStartTime { S7_SetPoint := 'True'} : Int;
      StepEndTime { S7_SetPoint := 'True'} : Int;
      StepMaxTime { S7_SetPoint := 'True'} : Int;
   END_STRUCT;

END_TYPE

TYPE "ParamSequencer"
VERSION : 0.1
   STRUCT
      Step : Array[0..99] of "ParamSequencerStep";
      Control : "ParamSequencerControl";
   END_STRUCT;

END_TYPE

TYPE "ParamMawomat"
VERSION : 0.1
   STRUCT
      paramTurnOnDelay { S7_SetPoint := 'True'} : DInt;   // Czas opóźnienia załączenia [s]
      paramTurnOffDelay { S7_SetPoint := 'True'} : DInt;   // Czas opóźnienia wyłączenia [s]
      paramAlarmDelay { S7_SetPoint := 'True'} : DInt;   // Czas opóźnienia alarmu od potwierdzeń [s]
      paramCmdOper : Word := 16#0045;   // Komendy manualne (5-Auto+SterowanieOn, 45- +Sprawdzanie potwierdzeń)
      paramSimOper : Word;   // Komendy symulacji
      statusFaultCode : Byte;   // Kod awarii
      statusStatus : Int;   // Status ( 1-awaria; 2-Wył; 4-Załączanie; 8-Zał; 16-Wyłączanie)
      statusControlMode : Int;   // Tryb pracy (1-remont; 2-lokal; 4-manual; 8-auto)
   END_STRUCT;

END_TYPE

TYPE "ParamSinamics"
VERSION : 0.1
   STRUCT
      RefSpeed { S7_SetPoint := 'True'} : Real;
      SpSpeed { S7_SetPoint := 'True'} : Real;
      ActSpeed : Real;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "ParamConfig"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR RETAIN
      DM : Array[0..10] of "ParamMawomat";
      Sinamics : Array[0..10] of "ParamSinamics";
      Sequencer : Array[0..10] of "ParamSequencer";
   END_VAR


BEGIN
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "ObjectSinamics"
TITLE = 'Speed Control with SINAMICS and S7'
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : DRVDPS7
FAMILY : DRIVES
NAME : SINA_SPD
VERSION : 5.1
//Copyright (C) Siemens AG 2012. All Rights Reserved. Confidential
//-------------------------------------------------------------------------------------- 
//SINA_SPEED: Drehzahlregelung mit dem Antriebsbaustein SINAMICS S120/G120 <-> S7-1200
//------------------------------------------------------------------------------------- Ersteller: Siemens AG Erlangen A&D MC PM   Datum:  07.07.10        Vers.:2.1
//Änderung:  J.B. Typical Team                       07.12.12              2.2
//    Umsetzung in SCL / TIA 
//Änderung:  J.B. Typical Team                       29.04.13              2.3
//    1. "Q" an den AusgÃ¤nge entfernen
//    2. Neuer Ausgang PwrInhibit
//Änderung:  J.B. Typical Team                       28.06.13              2.4
//    Ã„nderung HW-Zugriff Ã¼ber LOG2MOD
//     
//Änderung:  J.B. Typical Team                       18.07.13              2.5
//    Ã„nderung HW-Zugriff Ã¼ber zwei HW-EingÃ¤nge
//
//Änderung:  J.B. Typical Team                       17.07.14              3.0
//    Optimmierung
//
//Änderung:  J.B. Typical Team                       30.07.14              4.0
//    Festlegung auf einheitlicher neuer Version 4.0
//
//Änderung:  P.Z. Typical Team                       03.12.15              4.1
//    Schnittstelle an Programmierleitfadeb TIA-Potal angepasst
//    zusÃ¤tzlicher Eingang "ConfigAxis" fÃ¼r STW-Bits
//
//Änderung:  G.F. Typical Team                       01.03.16              4.2
//    Sollwert auf INT - Grenzen begrenzt
//Änderung:  F.G. Typical Team                       13.09.16              4.3
//    Ausgabewerte am Ausgang "Status" angepasst 
//
//Änderung:  G.F. Typical Team                       11.01.17              5.0
//    - Festlegung auf einheitlicher neuer Version 5.0 
//
//Änderung:  G.F. Typical Team                       03.05.18              5.1
//    - Alle Bits des Eingang ConfigAxis auf STW1 aufgelegt 
//
//Bibliothek V7
//Funktion: Drehzahlregelung mit dem Antriebsbaustein SINAMICS S120/G120 <-> S7-1200
//********************************************************************************************************************************************************
//************************************************************************FB283***************************************************************************
//********************************************************************************************************************************************************
   VAR_INPUT 
      EnableAxis : Bool := 0;   // 0-->1; 1 = Enable the drive (OFF2 / OFF 3 are 1 in default status) (OFF1 = 0-->1)
      AckError : Bool := 0;   // 1 = Acknowledge drive error
      ControlMode : Int;   // Mawomat Object Control Mode 8- Auto; 4 - Manual
      SpeedSP : Int;   // Speed setpiont
      ConfigAxis : Word := 16#003F;   // binary programmed input to control all functions in the telegram without its own function block input
      HWIDSTW : HW_IO := 0;   // Hardware Identifer set point slot
      HWIDZSW : HW_IO := 0;   // Hardware Identifer actual value slot
   END_VAR

   VAR_OUTPUT 
      AxisEnabled : Bool := 0;   // 1 = Drive is enabled
      Lockout : Bool := 0;   // 1 = Drive lockout active
      Error : Bool := 0;   // 1 = Error  (FB and Infeed)
      Status : Word := 0;   // Status output (7002 = FB in operation; 8xxx = error description  - read the manual)
      DiagId : Word := 16#0000;   // Error codes of the cyclic system funtion blocks DPWR / DPRD_DAT
   END_VAR

   VAR_IN_OUT 
      Param : "ParamSinamics";
   END_VAR

   VAR 
      sxSendBuf : Struct   // Send buffer
         STW1 : Word := WORD#16#0000;   // STW1sxSTW1     : STRUCT            Bit08       : BOOL:=False;              // ST-Wort-1 Bit 08 --> Reserve            Bit09       : BOOL:=False;              // ST-Wort-1 Bit 09 --> Reserve            Bit10       : BOOL:=True;               // ST-Wort-1 Bit 10 --> FÃ¼hrung durch PLC            Dir         : BOOL:=False;              // ST-Wort-1 Bit 11 --> Direction            Bit12       : BOOL:=False;              // ST-Wort-1 Bit 12 --> Haltebremse unbedingt Ã¶ffnen            Bit13       : BOOL:=False;              // ST-Wort-1 Bit 13 --> Motorpotenziometer Sollwert hÃ¶her            Bit14       : BOOL:=False;              // ST-Wort-1 Bit 14 --> Motorpotenziometer Sollwert tiefer            Bit15       : BOOL:=False;              // ST-Wort-1 Bit 15 --> Reserviert            Off1        : BOOL:=False;              // ST-Wort-1 Bit 00 --> OFF1/ON (flanks acceptance)            Off2        : BOOL:=True;               // ST-Wort-1 Bit 01 --> OFF2/ON (enable possible)            Off3        : BOOL:=True;               // ST-Wort-1 Bit 02 --> OFF3/ON (enable possible)            InvEn       : BOOL:=True;               // ST-Wort-1 Bit 03 --> Enable controller            RampEn      : BOOL:=True;               // ST-Wort-1 Bit 04 --> Ramp enable            RampOn      : BOOL:=True;               // ST-Wort-1 Bit 05 --> Ramp On            SpEn        : BOOL:=True;               // ST-Wort-1 Bit 06 --> Speed set point enable            AckFlt      : BOOL:=False;              // ST-Wort-1 Bit 07 --> Acknowledge fault         END_STRUCT;
         Velocity : Word := WORD#16#0000;   // Setpoint of velocity
      END_STRUCT;
      sxRecvBuf : Struct   // Receive buffer
         ZSW1 : Word := WORD#16#0000;   // ZSW1sxZSW1     : STRUCT            SpDev       : BOOL:=False;              // ZSW-Wort-1 = Schleppfehler im Toleranzbereich            Pcd         : BOOL:=False;              // ZSW-Wort-1 = PZD-FÃ¼hrung erreicht            Comp        : BOOL:=False;              // ZSW-Wort-1 = Zielposition erreicht            CurLim      : BOOL:=False;              // ZSW-Wort-1 = Referenzpunkt gesetzt            Brake       : BOOL:=False;              // ZSW-Wort-1 = Haltebremse Ã¶ffnen            Motover     : BOOL:=False;              // ZSW-Wort-1 = keine Warnung Ãœbertemperatur Motor            Dir         : BOOL:=False;              // ZSW-Wort-1 = Direction            Invover     : BOOL:=False;              // ZSW-Wort-1 = keine Warnung thermische Ãœberlast Leistungsteil            Rts         : BOOL:=False;              // ZSW-Wort-1 = Ready to power up / to start            Rdy         : BOOL:=False;              // ZSW-Wort-1 = Ready to operate            IOp         : BOOL:=False;              // ZSW-Wort-1 = In operation (operation enabled)            Fault       : BOOL:=False;              // ZSW-Wort-1 = Fault present            NoOff2      : BOOL:=False;              // ZSW-Wort-1 = OFF2 inactive            NoOff3      : BOOL:=False;              // ZSW-Wort-1 = OFF3 inactive            Inhibit     : BOOL:=False;              // ZSW-Wort-1 = Power ON inhibit active             Alarm       : BOOL:=False;              // ZSW-Wort-1 = Alarm / Warning present                     END_STRUCT;
         Velocity : Word := WORD#16#0000;   // Feedback of velocity
      END_STRUCT;
      sRefSpeed : Real := 0.0;   // Standardisation factor of speed
      sActVelocity : Real := 0.0;   // Actual in [U/min]
      sSpeedSp : Real := 0.0;   // Speed standardises with the standardisation factor
   END_VAR

   VAR_TEMP 
      piRetSFC : Int;   // Status for fault analysis
      piCount : Int;   // Freely available counter variable 3
      prVelocity : Real;   // velocity
      pdRecvBuf : DWord;   // Buffer of Recv-Value
      pdSendBuf : DWord;   // Buffer of Send-Value
      phLAddr : HW_IO;   // Start addr from the I/O process image area of mod (DEC) for DPWR_DAT/DPRD_DAT
      swSendBuf : Array[0..1] of Word;   // Sendepuffer
      swRecvBuf : Array[0..1] of Word;   // Empfangspuffer         Static variables
   END_VAR


BEGIN
	
	//=============================================================================
	//SIEMENS AG
	//(c)Copyright 2017 All Rights Reserved
	//-----------------------------------------------------------------------------
	// Library: DriveLib
	// Tested with: S7-1516-3 PN/DP V1.8
	// Engineering: TIA Portal V14
	// Restrictions: -
	// Requirements: S7-1200 / S7-1500
	// Functionality: cyclic communication between a SINAMICS a PLC.
	//                If in HWConfig Std.TLG 1 is projected 2 PZD-words are exchanged
	//                in every bus cycle.
	//                The parametrisation of these words is described in the manual of the
	//                SINAMICS
	//=============================================================================
	
	// Schreibdaten zusammenstellen
	// Steuerword aufbereiten
	// 
	
	// ================================
	// Author: Adam
	// Version: 1.0
	// Date: 2025-05-16
	// Description: Sinamics control class for TIA Portal
	// ================================
	
	
	#sRefSpeed := #Param.RefSpeed;
	
	IF #ControlMode = 4 THEN
	    
	    #sSpeedSp := #Param.SpSpeed;
	    
	ELSIF #ControlMode = 8 THEN
	    
	    #sSpeedSp := #SpeedSP;
	    
	END_IF;
	
	
	#Param.SpSpeed := #sSpeedSp;
	
	#sxSendBuf.STW1.%X0 := #EnableAxis;
	#sxSendBuf.STW1.%X1 := #ConfigAxis.%X0;
	#sxSendBuf.STW1.%X2 := #ConfigAxis.%X1;
	#sxSendBuf.STW1.%X3 := #ConfigAxis.%X2;
	#sxSendBuf.STW1.%X4 := #ConfigAxis.%X3;
	#sxSendBuf.STW1.%X5 := #ConfigAxis.%X4;
	#sxSendBuf.STW1.%X6 := #ConfigAxis.%X5;
	#sxSendBuf.STW1.%X7 := #AckError;
	#sxSendBuf.STW1.%X8 := #ConfigAxis.%X10;
	#sxSendBuf.STW1.%X9 := #ConfigAxis.%X11;
	#sxSendBuf.STW1.%X10 := TRUE;
	#sxSendBuf.STW1.%X11 := #ConfigAxis.%X6;
	#sxSendBuf.STW1.%X12 := #ConfigAxis.%X7;
	#sxSendBuf.STW1.%X13 := #ConfigAxis.%X8;
	#sxSendBuf.STW1.%X14 := #ConfigAxis.%X9;
	#sxSendBuf.STW1.%X15 := #ConfigAxis.%X12;
	
	// Geschwindigkeit
	IF #sRefSpeed <> 0 THEN
	  #prVelocity := #sSpeedSp * (16384.0 / #sRefSpeed);
	  // Limit REAL - Variable to INT - Limits
	  IF #prVelocity > 32767 THEN
	    #prVelocity := 32767;
	  ELSIF #prVelocity < -32768 THEN
	    #prVelocity := -32768;
	  ELSE
	    ; // not needed
	  END_IF;
	  #sxSendBuf.Velocity := INT_TO_WORD(REAL_TO_INT(#prVelocity));
	  
	ELSE
	  #sxSendBuf.Velocity := W#16#0;
	END_IF;
	#swSendBuf[0] := #sxSendBuf.STW1;
	#swSendBuf[1] := #sxSendBuf.Velocity;
	
	//Prozessdaten zur Signalbaugruppe schreiben
	#piRetSFC := DPWR_DAT(LADDR := #HWIDSTW,
	                      RECORD := #swSendBuf);
	
	// Fehler der RÃ¼ckmeldung ausgeben
	#DiagId := INT_TO_WORD(#piRetSFC);
	
	//kein Fehler beim Schreiben
	IF #piRetSFC = 0 THEN
	  
	  //kein Fehler beim Schreiben
	  IF #piRetSFC = 0 THEN
	    
	    //Prozessdaten von der Signalbaugruppe lesen
	    #piRetSFC := DPRD_DAT(LADDR := #HWIDZSW,
	                          RECORD => #swRecvBuf);
	    
	    // Fehler der RÃ¼ckmeldung ausgeben
	    #DiagId := INT_TO_WORD(#piRetSFC);
	  END_IF;
	  
	  //Fehler beim Lesen (Profibus-Kommunikation unterbrochen)
	  IF #piRetSFC <> 0 THEN
	    
	    // Fehler
	    #Error := TRUE;
	    #Status := 16#8600;
	    
	    // Zustandsworte lÃ¶schen
	    #sxRecvBuf.ZSW1.%X8 := 0;
	    #sxRecvBuf.ZSW1.%X9 := 0;
	    #sxRecvBuf.ZSW1.%X10 := 0;
	    #sxRecvBuf.ZSW1.%X11 := 0;
	    #sxRecvBuf.ZSW1.%X12 := 0;
	    #sxRecvBuf.ZSW1.%X13 := 0;
	    #sxRecvBuf.ZSW1.%X14 := 0;
	    #sxRecvBuf.ZSW1.%X15 := 0;
	    #sxRecvBuf.ZSW1.%X0 := 0;
	    #sxRecvBuf.ZSW1.%X1 := 0;
	    #sxRecvBuf.ZSW1.%X2 := 0;
	    #sxRecvBuf.ZSW1.%X3 := 0;
	    #sxRecvBuf.ZSW1.%X4 := 0;
	    #sxRecvBuf.ZSW1.%X5 := 0;
	    #sxRecvBuf.ZSW1.%X6 := 0;
	    #sxRecvBuf.ZSW1.%X7 := 0;
	    
	    
	    (*#sxRecvBuf.sxZSW1.SpDev   := 0;
	    #sxRecvBuf.sxZSW1.Pcd     := 0;
	    #sxRecvBuf.sxZSW1.Comp    := 0;
	    #sxRecvBuf.sxZSW1.CurLim  := 0;
	    #sxRecvBuf.sxZSW1.Brake   := 0;
	    #sxRecvBuf.sxZSW1.Motover := 0;
	    #sxRecvBuf.sxZSW1.Dir     := 0;
	    #sxRecvBuf.sxZSW1.Invover := 0;
	    #sxRecvBuf.sxZSW1.Rts     := 0;
	    #sxRecvBuf.sxZSW1.Rdy     := 0;
	    #sxRecvBuf.sxZSW1.IOp     := 0;
	    #sxRecvBuf.sxZSW1.Fault   := 0;
	    #sxRecvBuf.sxZSW1.NoOff2  := 0;
	    #sxRecvBuf.sxZSW1.NoOff3  := 0;
	    #sxRecvBuf.sxZSW1.Inhibit := 0;
	    #sxRecvBuf.sxZSW1.Alarm   := 0;*)
	    
	    #sxRecvBuf.Velocity := W#16#00;
	    
	    // Werte auslesen
	  ELSE
	    #sxRecvBuf.ZSW1 := #swRecvBuf[0];
	    #sxRecvBuf.Velocity := #swRecvBuf[1];
	    
	    // ZSW1 aufbereiten                       
	    #AxisEnabled := #sxRecvBuf.ZSW1.%X2;
	    #Error := #sxRecvBuf.ZSW1.%X3 OR #sxRecvBuf.ZSW1.%X6;
	    #Lockout := #sxRecvBuf.ZSW1.%X6;
	    
	    // Fehler auswerten
	    IF #sxRecvBuf.ZSW1.%X3 THEN
	      #Status := 16#8401;
	    ELSIF #sxRecvBuf.ZSW1.%X6 THEN
	      #Status := 16#8402;
	    ELSE
	      #Status := 16#7002;
	    END_IF;
	    
	    (*#Busy       := #sxRecvBuf.sxZSW1.IOp;
	    #Error      := #sxRecvBuf.sxZSW1.Fault OR #sxRecvBuf.sxZSW1.Inhibit;
	    #PwrInhibit := #sxRecvBuf.sxZSW1.Inhibit;            
	
	    // Fehler auswerten
	    IF #sxRecvBuf.sxZSW1.Fault THEN
	        #ErrorId := 1;
	    ELSIF #sxRecvBuf.sxZSW1.Inhibit THEN 
	        #ErrorId := 2;
	    ELSE
	        #ErrorId := 0;    
	    END_IF;*)
	    
	    // Geschwindigkeit
	    IF #sRefSpeed <> 0 THEN
	        #Param.ActSpeed := INT_TO_REAL(WORD_TO_INT(#sxRecvBuf.Velocity)) / (16384.0 / #sRefSpeed);
	    ELSE
	        #Param.ActSpeed := 0.0;
	    END_IF;
	  END_IF;
	ELSE
	  
	  // Fehler
	  #Error := TRUE;
	  #Status := 16#8601;
	  
	END_IF;
	
	
END_FUNCTION_BLOCK

DATA_BLOCK "Param"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
"ParamConfig"

BEGIN
   DM[0].paramTurnOnDelay := 2;
   DM[0].paramTurnOffDelay := 10;
   DM[0].paramAlarmDelay := 7;
   DM[1].paramTurnOnDelay := 0;
   DM[1].paramTurnOffDelay := 0;
   DM[1].paramAlarmDelay := 0;
   DM[2].paramTurnOnDelay := 0;
   DM[2].paramTurnOffDelay := 0;
   DM[2].paramAlarmDelay := 0;
   DM[3].paramTurnOnDelay := 0;
   DM[3].paramTurnOffDelay := 0;
   DM[3].paramAlarmDelay := 0;
   DM[4].paramTurnOnDelay := 0;
   DM[4].paramTurnOffDelay := 0;
   DM[4].paramAlarmDelay := 0;
   DM[5].paramTurnOnDelay := 0;
   DM[5].paramTurnOffDelay := 0;
   DM[5].paramAlarmDelay := 0;
   DM[6].paramTurnOnDelay := 0;
   DM[6].paramTurnOffDelay := 0;
   DM[6].paramAlarmDelay := 0;
   DM[7].paramTurnOnDelay := 0;
   DM[7].paramTurnOffDelay := 0;
   DM[7].paramAlarmDelay := 0;
   DM[8].paramTurnOnDelay := 0;
   DM[8].paramTurnOffDelay := 0;
   DM[8].paramAlarmDelay := 0;
   DM[9].paramTurnOnDelay := 0;
   DM[9].paramTurnOffDelay := 0;
   DM[9].paramAlarmDelay := 0;
   DM[10].paramTurnOnDelay := 0;
   DM[10].paramTurnOffDelay := 0;
   DM[10].paramAlarmDelay := 0;
   Sinamics[0].RefSpeed := 1500.0;
   Sinamics[0].SpSpeed := 100.0;
   Sinamics[1].RefSpeed := 0.0;
   Sinamics[1].SpSpeed := 0.0;
   Sinamics[2].RefSpeed := 0.0;
   Sinamics[2].SpSpeed := 0.0;
   Sinamics[3].RefSpeed := 0.0;
   Sinamics[3].SpSpeed := 0.0;
   Sinamics[4].RefSpeed := 0.0;
   Sinamics[4].SpSpeed := 0.0;
   Sinamics[5].RefSpeed := 0.0;
   Sinamics[5].SpSpeed := 0.0;
   Sinamics[6].RefSpeed := 0.0;
   Sinamics[6].SpSpeed := 0.0;
   Sinamics[7].RefSpeed := 0.0;
   Sinamics[7].SpSpeed := 0.0;
   Sinamics[8].RefSpeed := 0.0;
   Sinamics[8].SpSpeed := 0.0;
   Sinamics[9].RefSpeed := 0.0;
   Sinamics[9].SpSpeed := 0.0;
   Sinamics[10].RefSpeed := 0.0;
   Sinamics[10].SpSpeed := 0.0;

END_DATA_BLOCK

FUNCTION_BLOCK "ClassSinamics"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      pompa : "ObjectSinamics";
   END_VAR

   VAR_TEMP 
      tempPIDControl : Bool;
      tempPIDSP : Int;
   END_VAR


BEGIN
	#pompa.EnableAxis := "DM".pompa.oControl;
	#pompa.AckError := "DM".pompa.oAckFault;
	#pompa.ControlMode := "DM".pompa.oControlMode;
	#pompa.HWIDSTW := "Drive_2~PROFINET_interface~SIEMENS_telegram_354";
	#pompa.HWIDZSW := "Drive_2~PROFINET_interface~SIEMENS_telegram_354";
	
	#pompa("Param":="Param".Sinamics[0]);
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "ObjectDM"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      inTurnOnConfirm { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Potwierdzenie załączenia
      inTurnOffConfirm { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Potwierdzenie wyłączenia
      inCircBreaker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gotowość obiektu - rozłącznik
      inPTC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Gotowość obiektu - PTC
      inReadySpare1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Gotowość obiektu - rezerwa
      inReadySpare2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Gotowość obiektu - rezerwa
      inLocalMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tryb lokalny
      inRemoteMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Tryb remontowy
      inExtFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Błąd zewnętrzny
      inLockAutoMan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Blokada przełączenia trybu Auto-Manual
      inInterlock { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Interlok
      inDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Kierunek obrotów (1-odwrotny)
      inGlobalAckFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Globalny reset
      inAutoOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Resetowanie sterowania na końcu
   END_VAR

   VAR_OUTPUT 
      oControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wyjście sterujące
      oControlDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wyjście strujące kierunkiem obrotów
      oAckFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wyjście reset obiektu
      oFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wyjście awaria
      oTurnedOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Załączone
      oTurnedOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wyłączone
      oControlMode : Int;   // Tryb pracy (1-remont; 2-lokal; 4-manual; 8-auto)
   END_VAR

   VAR_IN_OUT 
      Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Załączanie z programu
      Object : "ParamMawomat";
   END_VAR

   VAR 
      statReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statManAuto { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statSymOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statSwitchEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statManTurnOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statManDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statSwitchControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statFaultReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statActivate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statTurnOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statTurnOnConfirm { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statTurnOffConfirm { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statLocal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statRemote { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statExtFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statLockAutoMan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statInterlock { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      tofTurnOnDelay {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      tofTurnOffDelay {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TOF_TIME;
      tonAlarm {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      statAlarmStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statFault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statControlMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      statControl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statTmrOnOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      trigGlobalReset {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      statFaultCond1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statFaultCond2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statFaultCond3 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statFaultCond4 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statFaultModeCond { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR CONSTANT 
      MODE_REMOTE : Int := 1;
      MODE_LOCAL : Int := 2;
      MODE_MANUAL : Int := 4;
      MODE_AUTO : Int := 8;
      STATUS_FAULT : Int := 1;
      STATUS_OFF : Int := 2;
      STATUS_STARTING : Int := 4;
      STATUS_ON : Int := 8;
      STATUS_STOPPING : Int := 16;
   END_VAR


BEGIN
	// ================================
	// Author: Adam
	// Version: 1.4
	// Date: 2025-05-05
	// Description: Motor control class for TIA Portal
	// ================================
	
	REGION Rewriting inputs
	    
	    //Operator Control Word
	    #statManAuto := #"Object".paramCmdOper.%X0;
	    #statSymOn := #"Object".paramCmdOper.%X1;
	    #statSwitchEnable := #"Object".paramCmdOper.%X2;
	    #statManTurnOn := #"Object".paramCmdOper.%X3;
	    #statManDirection := #"Object".paramCmdOper.%X4;
	    #statSwitchControl := #"Object".paramCmdOper.%X6;
	    
	    //Operator Control Word Impulses
	    #trigGlobalReset(CLK := #inGlobalAckFault);
	    
	    #statFaultReset := #trigGlobalReset.Q OR #"Object".paramCmdOper.%X7;
	    
	END_REGION
	
	REGION Rewriting inputs or simulation signals to statics
	    
	    IF NOT #statSymOn THEN
	        
	        #statTurnOn := #Enable;
	        #statTurnOnConfirm := #inTurnOnConfirm;
	        #statTurnOffConfirm := #inTurnOffConfirm;
	        #statReady := #inCircBreaker AND #inPTC AND #inReadySpare1 AND #inReadySpare2;
	        #statLocal := #inLocalMode;
	        #statRemote := #inRemoteMode;
	        #statExtFault := #inExtFault;
	        #statLockAutoMan := #inLockAutoMan;
	        #statInterlock := #inInterlock;
	        #statDirection := #inDirection;
	        
	        //Rewriting inputs to simulation bits when simulotion is to switch fluently
	        #"Object".paramSimOper.%X0 := #statActivate;
	        #"Object".paramSimOper.%X1 := #statTurnOn;
	        #"Object".paramSimOper.%X2 := #statTurnOnConfirm;
	        #"Object".paramSimOper.%X3 := #statTurnOffConfirm;
	        #"Object".paramSimOper.%X4 := #statReady;
	        #"Object".paramSimOper.%X5 := #statLocal;
	        #"Object".paramSimOper.%X6 := #statRemote;
	        #"Object".paramSimOper.%X7 := #statExtFault;
	        #"Object".paramSimOper.%X8 := #statLockAutoMan;
	        #"Object".paramSimOper.%X9 := #statInterlock;
	        #"Object".paramSimOper.%X10 := #statDirection;
	        
	    ELSE
	        
	        #statActivate := #"Object".paramSimOper.%X0;
	        #statTurnOn := #"Object".paramSimOper.%X1;
	        #statTurnOnConfirm := #"Object".paramSimOper.%X2;
	        #statTurnOffConfirm := #"Object".paramSimOper.%X3;
	        #statReady := #"Object".paramSimOper.%X4;
	        #statLocal := #"Object".paramSimOper.%X5;
	        #statRemote := #"Object".paramSimOper.%X6;
	        #statExtFault := #"Object".paramSimOper.%X7;
	        #statLockAutoMan := #"Object".paramSimOper.%X8;
	        #statInterlock := #"Object".paramSimOper.%X9;
	        #statDirection := #"Object".paramSimOper.%X10;
	        
	    END_IF;
	    
	    
	END_REGION
	
	REGION Control Mode
	    
	    IF #statRemote THEN
	        
	        #statControlMode := #MODE_REMOTE;
	        
	    ELSIF #statLocal THEN
	        
	        #statControlMode := #MODE_LOCAL;
	        
	    ELSIF NOT #statManAuto AND NOT #statLockAutoMan THEN
	        
	        #statControlMode := #MODE_MANUAL;
	        
	    ELSIF #statManAuto AND NOT #statLockAutoMan THEN
	        
	        #statControlMode := #MODE_AUTO;
	        
	    END_IF;
	    
	END_REGION
	
	REGION TurnOn/Off Delay
	    
	    #tofTurnOnDelay(IN := #statTurnOn,
	                    PT := 1000 * #"Object".paramTurnOnDelay);
	    
	    #tofTurnOffDelay(IN := #statTurnOn,
	                     PT := 1000 * #"Object".paramTurnOffDelay);
	    
	    IF #tofTurnOnDelay.Q THEN
	        
	        #statTmrOnOff := TRUE;
	        
	    END_IF;
	    
	    IF NOT #tofTurnOffDelay.Q THEN
	        
	        #statTmrOnOff := FALSE;
	        
	    END_IF;
	END_REGION
	
	REGION Fault 
	    
	    #statFaultModeCond :=
	    #statSwitchControl AND //is switch controling on
	    #statSwitchEnable AND //is objects output is eneble to turn on
	    #statControlMode <> #MODE_LOCAL AND //in local mode there is no alarm
	    #statControlMode <> #MODE_REMOTE;//in remote mode there is no alarm
	    
	    #statFaultCond1 := (#statControl XOR #statTurnOnConfirm);//xor  0110 - if A and B have different state then =1
	    #statFaultCond2 := (NOT #statControl XOR #statTurnOffConfirm);
	    #statFaultCond3 := (#statTurnOnConfirm AND #statTurnOffConfirm);
	    #statFaultCond4 := (NOT #statTurnOnConfirm AND NOT #statTurnOffConfirm);
	    
	    //Alarm from switching control 
	    #statAlarmStart :=
	    #statFaultModeCond AND
	    (#statFaultCond1 OR
	    #statFaultCond2 OR
	    #statFaultCond3 OR
	    #statFaultCond4);
	    
	    //Generating switching alarm after delay
	    #tonAlarm(IN := #statAlarmStart,
	              PT := DINT_TO_TIME(1000 * #"Object".paramAlarmDelay));
	    
	    
	    //Generating fault
	    IF #tonAlarm.Q OR NOT #statReady OR #statExtFault THEN
	        
	        #statFault := TRUE;
	        
	    ELSIF #statFaultReset THEN
	        
	        #statFault := FALSE;
	        
	    END_IF;
	    
	    //Fault code
	    #"Object".statusFaultCode.%X0 := #tonAlarm.Q;
	    #"Object".statusFaultCode.%X1 := NOT #statReady;
	    #"Object".statusFaultCode.%X2 := #statExtFault;
	    #"Object".statusFaultCode.%X3 := NOT #inCircBreaker;
	    #"Object".statusFaultCode.%X4 := NOT #inPTC;
	    #"Object".statusFaultCode.%X5 := NOT #inReadySpare1;
	    #"Object".statusFaultCode.%X6 := NOT #inReadySpare2;
	    
	END_REGION
	
	REGION Command locks
	    
	    IF #statControlMode = #MODE_AUTO AND #statLockAutoMan THEN
	        
	        #statManAuto := TRUE;
	        
	    ELSIF #statControlMode = #MODE_MANUAL AND #statLockAutoMan THEN
	        
	        #statManAuto := FALSE;
	        
	    END_IF;
	    
	    // Writing states from Local to Manual when object when switching Local to Manual
	    IF #statControlMode = #MODE_LOCAL THEN
	        
	        #statManAuto := FALSE;
	        
	        IF #statTurnOffConfirm THEN
	            
	            #statTurnOn := FALSE;
	            
	        ELSIF #statTurnOnConfirm THEN
	            
	            #statTurnOn := TRUE;
	            
	        END_IF;
	        
	    END_IF;
	    
	    // Writing states from Auto to Manual when object when switching Auto to Manual
	    // Przypadek gdy ktos z wlaczonym automatycznie urz. przechodzi na tryb zdalny-reczny
	    IF #statControlMode = #MODE_AUTO THEN
	        
	        #statManTurnOn := #statTurnOn;
	        #statManDirection := #statDirection;
	        
	    END_IF;
	    
	    //Resetowanie rozkazu zalaczenia w trybie manualnym po awarii
	    IF #statFault THEN
	        
	        #statManTurnOn := FALSE;
	        
	    END_IF;
	    
	    
	    
	    
	END_REGION
	
	REGION Control and Direction output
	    
	    IF #statSwitchEnable AND NOT #statInterlock AND NOT #statFault THEN
	        
	        IF #statControlMode = #MODE_AUTO THEN
	            
	            #statControl := #statTmrOnOff;
	            #oControlDirection := #statDirection;
	            
	        ELSIF #statControlMode = #MODE_MANUAL THEN
	            
	            #statControl := #statManTurnOn;
	            #oControlDirection := #statManDirection;
	            
	        ELSE
	            
	            #statControl := FALSE;
	            #oControlDirection := FALSE;
	            
	        END_IF;
	        
	    ELSE
	        
	        #statControl := FALSE;
	        #oControlDirection := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	
	REGION Reset Control
	    
	    #oAckFault := #statFaultReset;
	    
	END_REGION ;
	
	REGION Device status code
	    
	    IF #statFault THEN
	        #"Object".statusStatus := #STATUS_FAULT;
	    ELSE
	        
	        CASE #statControlMode OF
	            #MODE_REMOTE:
	                #"Object".statusStatus := #STATUS_OFF;
	            #MODE_LOCAL:
	                IF #statTurnOnConfirm THEN
	                    #"Object".statusStatus := #STATUS_ON;
	                ELSIF #statTurnOffConfirm THEN
	                    #"Object".statusStatus := #STATUS_OFF;
	                ELSIF #statControl THEN
	                    #"Object".statusStatus := #STATUS_STARTING;
	                ELSIF NOT #statControl THEN
	                    #"Object".statusStatus := #STATUS_STOPPING;
	                END_IF;
	            #MODE_MANUAL, #MODE_AUTO:
	                IF #statSwitchControl AND #statSwitchEnable THEN
	                    IF #statControl AND #statTurnOnConfirm AND NOT #statTurnOffConfirm THEN
	                        #"Object".statusStatus := #STATUS_ON;
	                    ELSIF NOT #statControl AND #statTurnOffConfirm AND NOT #statTurnOnConfirm THEN
	                        #"Object".statusStatus := #STATUS_OFF;
	                    ELSIF #statControl THEN
	                        #"Object".statusStatus := #STATUS_STARTING;
	                    ELSIF NOT #statControl THEN
	                        #"Object".statusStatus := #STATUS_STOPPING;
	                    END_IF;
	                ELSE
	                    IF #statControl THEN
	                        #"Object".statusStatus := #STATUS_ON;
	                    ELSIF NOT #statControl THEN
	                        #"Object".statusStatus := #STATUS_OFF;
	                    END_IF;
	                END_IF;
	            ELSE
	                #"Object".statusStatus := #STATUS_FAULT;
	        END_CASE;
	        
	        
	        
	    END_IF;
	    
	    CASE #"Object".statusStatus OF
	        #STATUS_ON:
	            #oTurnedOn := TRUE;
	            #oTurnedOff := FALSE;
	        #STATUS_OFF:
	            #oTurnedOff := TRUE;
	            #oTurnedOn := FALSE;
	        ELSE
	            #oTurnedOn := FALSE;
	            #oTurnedOff := FALSE;
	    END_CASE;
	    
	END_REGION ;
	
	
	REGION Reseting impuls
	    // Samokasowanie sygnalow
	    #statFaultReset := false;
	    
	    IF #inAutoOff THEN
	        
	        #statTurnOn := FALSE;
	        
	    END_IF;
	    
	END_REGION ;
	
	REGION Rewriting TO outputs
	    
	    #"Object".paramCmdOper.%X0 := #statManAuto;
	    #"Object".paramCmdOper.%X1 := #statSymOn;
	    #"Object".paramCmdOper.%X2 := #statSwitchEnable;
	    #"Object".paramCmdOper.%X3 := #statManTurnOn;
	    #"Object".paramCmdOper.%X4 := #statManDirection;
	    #"Object".paramCmdOper.%X6 := #statSwitchControl;
	    #"Object".paramCmdOper.%X7 := #statFaultReset;
	    
	    #"Object".statusControlMode := #statControlMode;
	    #oControlMode := #statControlMode;
	    
	    #oFault := #statFault;
	    
	    #Enable := #statTurnOn;
	    
	    #oControl := #statControl;
	END_REGION
	
END_FUNCTION_BLOCK

DATA_BLOCK "Sinamics"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"ClassSinamics"

BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "ClassDM"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      pompa { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "ObjectDM";
      pompa2 : "ObjectDM";
   END_VAR


BEGIN
	#pompa.inAutoOff := TRUE;
	#pompa.inCircBreaker := TRUE;
	#pompa.inPTC := TRUE;
	#pompa.inExtFault := "Sinamics".pompa.Error;
	
	#pompa.Enable := "Tag_1";
	
	#pompa(Object:="Param".DM[0]);
	
	
	#pompa2(Object:="Param".DM[1]);
	
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "Sequencer"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      start : Bool;
      stop : Bool;
      pause : Bool;
      inNexStepNb : Int;   // Numer kolejnego kroku z programu
      inStepStartTime : Int := 10;   // Czas od wejścia w krok do wykonywania warunków
      inStepEndTime : Int := 10;   // Czas od spełnienia warunku przejścia kroku do przejścia do następnego
      inStepMaxTime : Int;
   END_VAR

   VAR_OUTPUT 
      outStepNb : Int;   // Aktualny krok
      outCondEnable : Bool;   // Rozkaz wykoniania warunków
      outStepExceed : Bool;   // Informacja przekroczenia czasu kroku
   END_VAR

   VAR_IN_OUT 
      inStepEnd : Bool;   // Krok zakończony
      Param : "ParamSequencerControl";
   END_VAR

   VAR 
      sPause : Bool;
      sStepNb : Int;
      sStepNbOld : Int;
      sStepNbPrevious : Int;
      sStepStartTime : Time;
      sStepEndTime : Time;
      sStepMaxTime : Time;
      sStepStart { S7_SetPoint := 'True'} : Bool;
      trigStart {InstructionName := 'R_TRIG'; LibVersion := '1.0'} : R_TRIG;
      trigPause {InstructionName := 'R_TRIG'; LibVersion := '1.0'} : R_TRIG;
      tonStepStart {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;
      tonStepEnd {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;
      tonStepMax {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;
   END_VAR

   VAR_TEMP 
      tToStartTime : DInt;
      tToEndTime : DInt;
      tMaxStepTime : DInt;
   END_VAR


BEGIN
	// ================================
	// Author: Adam
	// Version: 1.0
	// Date: 2025-05-19
	// Description: Sequencer mechanics
	// Tryby:
	// Automatyczny - kroki przechodza po spelnieniu warunku inStepEnd do kroku inNexStepNb,
	// Manualny - kroki mozna przelaczac +/-1 oraz przechodzic do konkretnego kroku
	// Symulacja - kroki przechodza ale bez sygnalu sterowania outCondEnable
	// Parametry:
	// inStepStartTime - czas od wejscia kroku do wystawienia outStepStart, czyli warunku wykonywania instrukcji
	// inStepEndTime - czas po spelnieniu warunku przejscia kroku do przejscia do nastepnego kroku
	// inStepMaxTime - czas maksymalny kroku, po przekroczeniu wystawiane outStepExceed
	// start,stop,pauza - sterowanie z programu 
	// param.start, pause - sterowanie z zewnatrz 
	// start - sekwencer startuje
	// stop - sekwencer sie wylacza
	// pauza - sekwencer pozostaje w kroku, nie wysterowuje outCondEnable, wymagane odpauzowanie z zewnatrz
	// przez param.Pause = false, jezeli warunek pauzy z programu to po odpauzowaniu jest on ignorowany
	// jezeli caly czasu wystepuje - zbocze
	// ================================
	
	REGION Start Sequence
	    
	    #trigStart(CLK := #start);
	    
	    IF #trigStart.Q THEN
	        
	        #Param.Start := TRUE;
	        
	    ELSIF #stop THEN
	        
	        #Param.Start := FALSE;
	        
	    END_IF;
	    
	END_REGION
	
	REGION Pause sequence
	    
	    #trigPause(CLK := #pause);
	    
	    IF #trigPause.Q OR #Param.Pause THEN
	        
	        #Param.Pause := TRUE;
	        
	    ELSE
	        
	        #Param.Pause := FALSE;
	        
	    END_IF;
	    
	    
	END_REGION
	
	
	IF #Param.Start THEN
	    
	    REGION Operating Mode
	        
	        IF #Param.ManualMode THEN
	            
	            #sStepNb := #Param.ManualStepNb;
	            
	            REGION Step +/- 1
	                
	                IF #Param.ManualStepUp THEN
	                    
	                    #sStepNb := #inNexStepNb;
	                    
	                ELSIF #Param.ManualStepDown THEN
	                    
	                    #sStepNb := #sStepNbPrevious;
	                    
	                END_IF;
	                
	            END_REGION
	            
	        ELSE
	            
	             IF #sStepNb = 0 THEN
	                
	                 #sStepNb := 1;
	                
	             ELSIF #tonStepEnd.Q THEN
	                
	                #sStepNb := #inNexStepNb;
	                #inStepEnd := FALSE;
	                
	            END_IF;
	            
	        END_IF;
	        
	    END_REGION
	    
	ELSE
	    
	    #sStepNb := 0;
	    #inStepEnd := FALSE;
	    
	END_IF;
	
	
	REGION Step Start 
	    
	    IF #Param.Start AND #sStepNb<>#sStepNbOld OR NOT #Param.Start THEN
	        
	        #sStepStart := FALSE;
	    ELSE
	        
	        #sStepStart := TRUE;
	        
	    END_IF;
	    
	    
	END_REGION
	
	
	    REGION Rewriting time start/end step to timer
	        
	        //Czas poczatku i konca kroku zdefiniowany dla calej sekwencji
	        //Mozna go nadpisywac w krokach 
	        #tToStartTime := 1000 * #inStepStartTime;
	        #tToEndTime := 1000 * #inStepEndTime;
	        #tMaxStepTime := 1000 * #inStepMaxTime;
	        
	        #sStepStartTime := DINT_TO_TIME(#tToStartTime);
	        #sStepEndTime := DINT_TO_TIME(#tToEndTime);
	        #sStepMaxTime := DINT_TO_TIME(#tMaxStepTime);
	        
	        
	    END_REGION
	   
	REGION Step start & end delay, max step time timers
	    
	    REGION Step start timer
	        
	        #tonStepStart(IN := #sStepStart,
	                      PT := #sStepStartTime);
	        
	    END_REGION
	    
	    REGION Max step time
	        
	        #tonStepMax(IN:=#tonStepStart.Q,
	                    PT:=#sStepMaxTime);
	        
	    END_REGION
	    
	    
	    REGION Step end timer
	        
	        #tonStepEnd(IN := #inStepEnd AND NOT #Param.Pause,
	                    PT := #sStepEndTime);
	
	    END_REGION
	    
	END_REGION
	
	REGION Step old
	    
	    IF #sStepNb<>#sStepNbOld THEN
	        
	        #sStepNbPrevious := #sStepNbOld;
	        
	    END_IF;
	    
	    #sStepNbOld := #sStepNb;
	    
	END_REGION
	
	REGION Reset impuls signals
	    
	    #Param.ManualStepUp := FALSE;
	    #Param.ManualStepDown := FALSE;
	    
	    
	END_REGION
	
	REGION Outputs
	    
	    #Param.StepNb := #sStepNb;
	    #Param.NextStepNb := #inNexStepNb;
	    #Param.StepNb:=#sStepNb;
	    #Param.StartTimeET := #tonStepStart.ET;
	    #Param.EndTimeET := #tonStepEnd.ET;
	    #Param.MaxTimeET := #tonStepMax.ET;
	    
	    #outStepNb := #sStepNb;
	    
	    #outCondEnable := #tonStepStart.Q AND NOT #Param.SimulationMode AND NOT #Param.Pause ;
	    
	    IF #inStepMaxTime <> 0 THEN
	        #outStepExceed := #tonStepMax.Q;
	    ELSE
	        #outStepExceed := FALSE;
	    END_IF;
	
	    
	END_REGION
	
	
	
	
	
END_FUNCTION_BLOCK

DATA_BLOCK "DM"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"ClassDM"

BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "Sequence1"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_IN_OUT 
      Param : "ParamSequencer";
   END_VAR

   VAR 
      Sequencer : "Sequencer";
   END_VAR


BEGIN
	// ================================
	// Author: Adam
	// Version: 1.0
	// Date: 2025-05-19
	// Description: Example sequence
	// Parametry:
	// Param.StepStartTime,Param.StepEndTime,Param.StepMaxTime - czas mozna wpisywac w kazdym kroku niezaleznie z zewnatrz
	// Param.StepNextStep - numer nastepnego kroku 
	
	// ================================
	REGION Przpysanie czasow krokow
	    
	    //Opcja 1 - wszystkie kroki maja takie same - czas wejscia, wyjscia i maksymalny nie maja znaczenia
	   // #Sequencer.inStepStartTime := 2;
	  //  #Sequencer.inStepEndTime := 2;
	 //   #Sequencer.inStepMaxTime := 0;
	    
	    //Opcja 2 - czasy sa brane z parametrow - sa wazne i mozna je parametryzowac z zewnatrz np hmi/scada
	        
	        #Sequencer.inStepStartTime := #Param.Step[#Sequencer.outStepNb].StepStartTime;
	        #Sequencer.inStepEndTime := #Param.Step[#Sequencer.outStepNb].StepEndTime;
	        #Sequencer.inStepMaxTime := #Param.Step[#Sequencer.outStepNb].StepMaxTime;
	
	    
	END_REGION
	
	    CASE #Sequencer.outStepNb OF
	            
	        0: //Krok 0 Manual
	            REGION Krok 0 Manual
	                
	                #Sequencer.inNexStepNb := 1;
	                
	            END_REGION
	
	        1:  // Krok 1
	            REGION Krok 1
	                
	                //Uncoditional actviations
	                
	                
	                //Conditional activations
	                IF #Sequencer.outCondEnable THEN
	                    // DM Class activations
	                    
	                    "DM".pompa.Enable := TRUE;
	                    
	                END_IF;
	                
	                // Next step 
	               
	                #Sequencer.inNexStepNb := 4;
	               
	                // Step end
	                 
	                #Sequencer.inStepEnd := "Tag_5";
	                
	                // Time exceed cond
	                
	                #Sequencer.pause := #Sequencer.outStepExceed;
	                
	            END_REGION
	
	            
	        2:  // Krok 2
	            
	            REGION Krok 2
	                
	                // DM Class activations
	                
	        //        "DB_DM".pump2Tank1in.ioTurnOn := TRUE;
	                
	            END_REGION
	            
	            // Step end
	            
	            #Sequencer.inStepEnd := "Tag_6";
	            
	            #Sequencer.inNexStepNb := 3;
	           
	       3: //Krok 3
	           
	           REGION Krok 3
	               
	               // DM Class activations
	               
	              // "DB_DM".pump2Tank1in.ioTurnOn := TRUE;
	               
	               
	               // DV Class activations
	               
	               //ddd
	               
	               
	               // "PID" Setpoint
	               
	       //        "PID_Tank1Level".Setpoint := 50;
	               
	               
	               // Sinamics Setpoint
	               
	               
	               //
	               
	               #Sequencer.inNexStepNb := 4;
	               
	          //     #Sequencer.inStepEnd := "Tag_7";
	               
	           END_REGION
	           
	       4:  // Krok 4
	           
	           REGION Krok 4
	               
	               // DM Class activations
	               
	    //           "DB_DM".pump2Tank1in.ioTurnOn := TRUE;
	               
	           END_REGION
	           
	           // Step end
	           
	           #Sequencer.inStepEnd := "Tag_6";
	           #Sequencer.inNexStepNb := 1;
	
	           
	        ELSE  // Statement section ELSE
	            
	            #Sequencer.inStepEnd := FALSE;
	            
	    END_CASE;
	
	    #Sequencer(Param:=#Param.Control);
	    
	    
	
	    
END_FUNCTION_BLOCK

